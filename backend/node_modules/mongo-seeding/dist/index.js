"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Seeder = void 0;
const common_1 = require("./common");
const database_1 = require("./database");
const transformer_1 = require("./transformer");
const importer_1 = require("./importer");
const config_1 = require("./config");
__exportStar(require("./config"), exports);
__exportStar(require("./helpers"), exports);
/**
 * Allows to seed database. It is a main Mongo Seeding class.
 */
class Seeder {
    /**
     * Constructs a new `Seeder` instance and loads configuration for data import.
     *
     * @param config Optional partial object with database seeding configuration. The object is merged with the default configuration object. To use all default settings, simply omit this parameter.
     */
    constructor(config) {
        /**
         * Configuration for seeding database.
         */
        this.config = config_1.defaultSeederConfig;
        /**
         * Populates collections and their documents from given path.
         * The path has to contain file structure described on https://github.com/pkosiec/mongo-seeding/blob/main/docs/import-data-definition.md.
         *
         * @param path File path
         * @param partialConfig Optional partial collection reading configuration object. It is merged with default configuration object. To use all default settings, simply omit this parameter.
         */
        this.readCollectionsFromPath = (path, partialConfig) => {
            const config = (0, config_1.mergeCollectionReadingOptions)(partialConfig);
            let collections;
            try {
                const { CollectionPopulator } = require('./populator');
                const populator = new CollectionPopulator(config.extensions, config.ejsonParseOptions, this.log);
                this.log(`Reading collections from ${path}...`);
                collections = populator.readFromPath(path);
            }
            catch (err) {
                throw wrapError(err);
            }
            if (config.transformers.length > 0) {
                this.log('Transforming collections...');
                collections = new transformer_1.CollectionTransformer().transform(collections, config.transformers);
            }
            return collections;
        };
        /**
         * Connects to a database and imports all collections.
         *
         * @param collections Array of collection definitions
         * @param partialConfig Optional partial configuration object. Ita allows to change the database seeding configuration for single data import.   It is merged with default configuration object. To use the configuration provided in `Seeder` constructor, simply omit this parameter.
         */
        this.import = (collections, partialConfig) => __awaiter(this, void 0, void 0, function* () {
            if (collections.length === 0) {
                this.log('No data to import. Finishing...');
                return;
            }
            this.log('Starting collection import...');
            const config = (0, config_1.mergeSeederConfig)(partialConfig, this.config);
            const databaseConnector = new database_1.DatabaseConnector(config.databaseReconnectTimeout, config.mongoClientOptions, this.log);
            let database;
            try {
                database = yield databaseConnector.connect(config.database);
                if (!config.dropDatabase && config.dropCollections) {
                    this.log('Dropping collections...');
                    for (const collection of collections) {
                        yield database.dropCollectionIfExists(collection.name);
                    }
                }
                if (!config.dropDatabase && config.removeAllDocuments) {
                    this.log('Removing all documents from collections...');
                    const promises = collections.map((collection) => database.removeAllDocumentsIfCollectionExists(collection.name));
                    yield Promise.all(promises);
                }
                if (config.dropDatabase) {
                    this.log('Dropping database...');
                    yield database.drop();
                }
                yield new importer_1.CollectionImporter(database, config.collectionInsertManyOptions, this.log).import(collections);
            }
            catch (err) {
                throw wrapError(err);
            }
            finally {
                if (database) {
                    yield database.closeConnection();
                }
            }
            this.log('Finishing...');
        });
        this.config = (0, config_1.mergeSeederConfig)(config);
        this.log = (0, common_1.NewLoggerInstance)();
    }
}
exports.Seeder = Seeder;
/**
 * Transformer functions for collections before data import.
 */
Seeder.Transformers = transformer_1.DefaultTransformers;
/**
 * Wraps error with custom name
 *
 * @param err Original error
 */
const wrapError = (err) => {
    err.name = 'MongoSeedingError';
    err.message = `${err.name}: ${err.message}`;
    return err;
};
//# sourceMappingURL=index.js.map