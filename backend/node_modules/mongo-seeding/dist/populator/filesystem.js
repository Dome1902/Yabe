"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.fileSystem = exports.FileSystem = void 0;
const fs_1 = require("fs");
const bson_1 = require("bson");
const path_1 = require("path");
const importFresh = require('import-fresh');
/**
 * Provides functionality for manipulating files and directories.
 */
class FileSystem {
    /**
     * Lists file names for a given path.
     *
     * @param path File path
     */
    listFileNames(path) {
        return (0, fs_1.readdirSync)(path) || [];
    }
    /**
     * Lists directories which are not empty or hidden.
     *
     * @param path File path
     */
    listValidDirectories(path) {
        const filesAndDirectories = this.listFileNames(path);
        const directories = filesAndDirectories.filter((fileOrDirectory) => {
            const itemPath = `${path}/${fileOrDirectory}`;
            return (this.isDirectory(itemPath) &&
                !this.isEmpty(itemPath) &&
                !this.isHidden(fileOrDirectory));
        });
        return directories;
    }
    /**
     * Checks if a directory is empty.
     *
     * @param path File path
     */
    isEmpty(path) {
        return this.listFileNames(path).length === 0;
    }
    /**
     * Checks if a file or directory is empty.
     *
     * @param fileOrDirectoryName File or directory name
     */
    isHidden(fileOrDirectoryName) {
        return fileOrDirectoryName.startsWith('.');
    }
    /**
     * Checks if a path is a directory.
     *
     * @param path File path
     */
    isDirectory(path) {
        const stats = (0, fs_1.lstatSync)(path);
        return stats.isDirectory();
    }
    /**
     * Filters files which are supported for database seeding.
     *
     * @param fileNames Array of file names
     * @param supportedExtensions Supported file extensions array
     */
    filterSupportedDocumentFileNames(fileNames, supportedExtensions) {
        const documentFileNames = fileNames.filter((fileName) => {
            const fileNameSplit = fileName.split(FileSystem.FILE_NAME_SPLIT_CHARACTER);
            if (this.shouldIgnoreFile(fileNameSplit)) {
                return false;
            }
            const fileExtension = fileNameSplit.pop();
            return supportedExtensions.some((extension) => extension.toLowerCase() === fileExtension.toLowerCase());
        });
        return documentFileNames;
    }
    /**
     * Checks if a file should be ignored based on extension.
     *
     * @param fileNameSplitByDot Array, which comes from file name split by dot
     */
    shouldIgnoreFile(fileNameSplitByDot) {
        const isHidden = !fileNameSplitByDot[0];
        const hasNoExtension = fileNameSplitByDot.length === 1;
        return isHidden || hasNoExtension;
    }
    /**
     * Reads content for multiple files.
     *
     * @param paths Array of paths
     */
    readFilesContent(paths, ejsonParseOptions) {
        return paths.reduce((arr, path) => {
            const fileContent = this.readFile(path, ejsonParseOptions);
            return arr.concat(fileContent);
        }, []);
    }
    /**
     * Reads a file from path. If it is a JSON, uses EJSON parser.
     *
     * @param path File path
     */
    readFile(path, ejsonParseOptions) {
        const fileExtension = (0, path_1.extname)(path);
        if (fileExtension !== '.json') {
            return importFresh(path);
        }
        const content = (0, fs_1.readFileSync)(path, 'utf-8');
        return bson_1.EJSON.parse(content, ejsonParseOptions);
    }
}
exports.FileSystem = FileSystem;
FileSystem.FILE_NAME_SPLIT_CHARACTER = '.';
/**
 * Default `FileSystem` instance
 */
exports.fileSystem = new FileSystem();
//# sourceMappingURL=filesystem.js.map