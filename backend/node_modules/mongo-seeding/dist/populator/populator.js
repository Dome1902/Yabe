"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CollectionPopulator = void 0;
const filesystem_1 = require("./filesystem");
/**
 * Populates collections from disk.
 */
class CollectionPopulator {
    /**
     * Constructs new `CollectionPopulator` object.
     *
     * @param extensions Array of file extensions
     */
    constructor(extensions, ejsonParseOptions, log) {
        if (extensions.length === 0) {
            throw new Error('Array of supported extensions must not be empty');
        }
        this.extensions = extensions;
        this.ejsonParseOptions = ejsonParseOptions;
        this.log = log ? log : () => { };
    }
    /**
     * Reads collections from path.
     *
     * @param path
     */
    readFromPath(path) {
        const subdirectories = filesystem_1.fileSystem.listValidDirectories(path);
        return this.readCollections(subdirectories, path);
    }
    /**
     * Read all collections from base path
     *
     * @param directories Array of directories names
     * @param inputDirectory Base directory
     */
    readCollections(directories, inputDirectory) {
        const collections = directories.reduce((collections, directoryName) => {
            const relativePath = `${inputDirectory}/${directoryName}`;
            const collection = this.readCollection(relativePath, directoryName);
            if (collection) {
                collections.push(collection);
            }
            return collections;
        }, []);
        return this.sortCollections(collections);
    }
    sortCollections(collections) {
        return collections.sort((a, b) => {
            const aOrderNo = typeof a.orderNo !== 'undefined' ? a.orderNo : Number.MAX_SAFE_INTEGER;
            const bOrderNo = typeof b.orderNo !== 'undefined' ? b.orderNo : Number.MAX_SAFE_INTEGER;
            if (aOrderNo > bOrderNo) {
                return 1;
            }
            if (aOrderNo < bOrderNo) {
                return -1;
            }
            return 0;
        });
    }
    /**
     * Reads collection along with documents content from a given path.
     *
     * @param path Collection Path
     * @param directoryName Directory name
     */
    readCollection(path, directoryName) {
        const { name, orderNo } = this.getCollectionMetadata(directoryName);
        const documents = this.populateDocumentsContent(path);
        if (!documents) {
            return null;
        }
        return {
            orderNo,
            name,
            documents,
        };
    }
    /**
     * Populates MongoDB documents content by reading files.
     *
     * @param collectionPath Path for a single collection
     */
    populateDocumentsContent(collectionPath) {
        const fileNames = filesystem_1.fileSystem.listFileNames(collectionPath);
        if (fileNames.length === 0) {
            this.log(`Directory '${collectionPath}' is empty. Skipping...`);
            return;
        }
        const documentFileNames = filesystem_1.fileSystem.filterSupportedDocumentFileNames(fileNames, this.extensions);
        if (documentFileNames.length === 0) {
            this.log(`No supported files found in directory '${collectionPath}'. Skipping...`);
            return;
        }
        const documentPaths = documentFileNames.map((fileName) => `${collectionPath}/${fileName}`);
        return filesystem_1.fileSystem.readFilesContent(documentPaths, this.ejsonParseOptions);
    }
    /**
     * Reads collection name from directory name.
     *
     * @param directoryName Directory name
     */
    getCollectionMetadata(directoryName) {
        const separators = /\s*[-_\.\s]\s*/;
        const isMatch = directoryName.match(separators);
        if (!isMatch) {
            return { name: directoryName };
        }
        const firstSeparator = isMatch[0];
        const splitArr = directoryName.split(firstSeparator);
        if (!this.isNumber(splitArr[0])) {
            return { name: directoryName };
        }
        const orderNo = Number(splitArr.shift());
        return {
            name: splitArr.join(firstSeparator),
            orderNo: orderNo,
        };
    }
    /**
     * Checks if a string is number.
     *
     * @param str String which can contain number
     */
    isNumber(str) {
        return /^\d+$/.test(str);
    }
}
exports.CollectionPopulator = CollectionPopulator;
//# sourceMappingURL=populator.js.map