"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ngAdd = void 0;
const tasks_1 = require("@angular-devkit/schematics/tasks");
const schematics_1 = require("@angular-devkit/schematics");
const util_1 = require("./../util");
function registerInPackageJson(_options) {
    return (tree, _context) => {
        if (_options.skipDeps) {
            _context.logger.info('Skip installing ngx-markdown-ediotr dependency(ace-builds/bootstrap/font-awesome) packages.');
            return tree;
        }
        if (tree.exists('package.json')) {
            const dependencies = {
                'ace-builds': '^1.4.9',
                'bootstrap': '^4.3.1',
                'font-awesome': '^4.7.0'
            };
            const packageInfo = JSON.parse((0, util_1.readFile)(tree, 'package.json'));
            let changed = false;
            for (let key in dependencies) {
                if (!packageInfo['dependencies'][key]) {
                    packageInfo['dependencies'][key] = dependencies[key];
                    changed = true;
                }
            }
            if (changed) {
                tree.overwrite('package.json', JSON.stringify(packageInfo, null, 2));
                _context.addTask(new tasks_1.NodePackageInstallTask());
            }
        }
        return tree;
    };
}
;
function updateAngularJson(_options) {
    return (tree, _context) => {
        if (_options.skipImport) {
            _context.logger.info('Skip assets/styles/scripts registration.');
            return tree;
        }
        const supportedTargets = new Set(['build', 'test']);
        const workspace = (0, util_1.getWorkspace)(tree);
        const project = (0, util_1.getProjectFromWorkspace)(workspace, _options.project);
        const targets = project.architect || project.targets;
        let aceAssets = {
            glob: "**/*",
            input: "node_modules/ace-builds/src-min",
            output: "./assets/ace-builds/"
        };
        let styles = [
            'node_modules/bootstrap/dist/css/bootstrap.min.css',
            'node_modules/font-awesome/css/font-awesome.min.css',
            'node_modules/ngx-markdown-editor/assets/highlight.js/agate.min.css'
        ];
        let scripts = [
            'node_modules/ngx-markdown-editor/assets/highlight.js/highlight.min.js',
            'node_modules/ngx-markdown-editor/assets/marked.min.js'
        ];
        Object.keys(targets).filter(key => supportedTargets.has(key)).forEach(key => {
            let target = targets[key];
            if (!target.options) {
                target.options = {
                    assets: [aceAssets],
                    styles: styles,
                    scripts: scripts
                };
            }
            else if (!target.options.assets || !target.options.styles || !target.options.scripts) {
                target.options.assets = target.options.assets || [aceAssets];
                target.options.styles = target.options.styles || styles;
                target.options.scripts = target.options.scripts || scripts;
            }
            else {
                styles = styles.reverse();
                scripts = scripts.reverse();
                let foundAceAsset = false;
                for (let asset of target.options.assets) {
                    if (typeof asset !== 'object' || !asset.input)
                        continue;
                    if (asset.input.indexOf('node_modules/ace-builds') !== -1) {
                        foundAceAsset = true;
                        break;
                    }
                }
                if (!foundAceAsset) {
                    target.options.assets.push(aceAssets);
                }
                const existingStyles = target.options.styles.map((s) => typeof s === 'string' ? s : s.input);
                for (let style of styles) {
                    const exists = existingStyles.find((s) => s.includes(style));
                    if (!exists) {
                        target.options.styles.splice(0, 0, style);
                    }
                }
                const existingScripts = target.options.scripts.map((s) => typeof s === 'string' ? s : s.input);
                for (let script of scripts) {
                    const exists = existingScripts.find((s) => s.includes(script));
                    if (!exists) {
                        target.options.scripts.splice(0, 0, script);
                    }
                }
            }
            tree.overwrite('angular.json', JSON.stringify(workspace, null, 2));
        });
        return tree;
    };
}
;
function ngAdd(_options) {
    return (tree, _context) => {
        return (0, schematics_1.chain)([
            registerInPackageJson(_options),
            updateAngularJson(_options)
        ])(tree, _context);
    };
}
exports.ngAdd = ngAdd;
//# sourceMappingURL=index.js.map